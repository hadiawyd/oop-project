#include <iostream>
#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>
#include <iomanip>

using namespace std;

// ---------- Vehicle Base Class ----------
class Vehicle {
protected:
    string plate;
    int arrivalHour;
public:
    Vehicle(string p, int h) : plate(p), arrivalHour(h) {}
    virtual ~Vehicle() {}
    string getPlate() { return plate; } //get plate number
    int getArrival() { return arrivalHour; } //arrival time

    virtual int requiredSlots() = 0; //slots required for each vehicle
    virtual bool needsCharger() { return false; } //charging function for EV's
    virtual double billing(int hours, double energy = 0) = 0; //bill for parking(varies with each vehicle), for EV energy consumed contributes to bill
    virtual string typeName() = 0; //output name
};

// ---------- Vehicle Types ----------
class Car : public Vehicle {
public:
    Car(string p, int h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 2.0 * hours; }
    string typeName() override { return "Car"; }
};

class ElectricCar : public Vehicle {
public:
    ElectricCar(string p, int h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    bool needsCharger() override { return true; }
    double billing(int hours, double energy = 0) override { return 2.0 * hours + 0.5 * hours; } //energy = hours parked for simplicity
    string typeName() override { return "ElectricCar"; }
    void startCharging() { cout << plate << " is now charging.\n"; }
};

class Truck : public Vehicle {
public:
    Truck(string p, int h) : Vehicle(p, h) {}
    int requiredSlots() override { return 2; }
    double billing(int hours, double energy = 0) override { return 3.5 * hours + 5.0; }
    string typeName() override { return "Truck"; }
};

class Rickshaw : public Vehicle {
public:
    Rickshaw(string p, int h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 1.5 * hours; }
    string typeName() override { return "Rickshaw"; }
};

// ---------- Motorbike Polymorphism ----------
class Motorbike : public Vehicle {
public:
    Motorbike(string p, int h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 0.6 * hours; }
    string typeName() override { return "Motorbike"; }
};

class NormalBike : public Motorbike {
public:
    NormalBike(string p, int h) : Motorbike(p, h) {}
    double billing(int hours, double energy = 0) override { return 0.6 * hours; }
    string typeName() override { return "NormalBike"; }
};

class HeavyBike : public Motorbike {
public:
    HeavyBike(string p, int h) : Motorbike(p, h) {}
    double billing(int hours, double energy = 0) override { return 1.0 * hours; }
    string typeName() override { return "HeavyBike"; }
};

// ---------- Parking Record ----------
struct ParkRecord {
    Vehicle* vehicle;
    int arrival;
    int exitHour; // -1 if not exited yet
    double energyUsed;
    string zone;
    double bill; // store final bill
};

// ---------- ParkingLot ----------
class ParkingLot {
    int normalSlotsAvailable;
    int evSlotsAvailable;
    int truckSlotsAvailable;
    vector<Vehicle*> waitingQueue;
    vector<ParkRecord> allVehicles; // includes parked and exited vehicles
public:
    ParkingLot(int normal, int ev, int truck)
        : normalSlotsAvailable(normal), evSlotsAvailable(ev), truckSlotsAvailable(truck) {
    }

    void parkVehicle(Vehicle* v) {
        string zone = "";
        bool parked = false;

        if (v->typeName() == "Truck") {
            if (truckSlotsAvailable >= v->requiredSlots()) {
                truckSlotsAvailable -= v->requiredSlots();
                zone = "Truck";
                parked = true;
            }
        }
        else if (v->needsCharger()) {
            if (evSlotsAvailable >= v->requiredSlots()) {
                evSlotsAvailable -= v->requiredSlots();
                zone = "EV";
                parked = true;
            }
        }
        else {
            if (normalSlotsAvailable >= v->requiredSlots()) {
                normalSlotsAvailable -= v->requiredSlots();
                zone = "Normal";
                parked = true;
            }
        }

        if (parked) {
            allVehicles.push_back({ v, v->getArrival(), -1, 0.0, zone, 0.0 });
            cout << "\n>> " << v->typeName() << " with plate " << v->getPlate() << " parked in " << zone << " zone.\n";

            // Vehicle-specific function example
            ElectricCar* ec = dynamic_cast<ElectricCar*>(v);
            if (ec) ec->startCharging();
        }
        else {
            waitingQueue.push_back(v);
            cout << "\n>> " << v->typeName() << " with plate " << v->getPlate() << " cannot be parked. Garage has reached its limit!\n";
        }
    }

    void exitVehicle(string plate, int hours) {
        int found = -1;
        for (int i = 0; i < allVehicles.size(); i++)
            if (allVehicles[i].vehicle->getPlate() == plate && allVehicles[i].exitHour == -1) {
                found = i;
                break;
            }

        if (found == -1) {
            cout << "Vehicle not found or already exited.\n";
            return;
        }

        ParkRecord& rec = allVehicles[found];
        double energy = 0.0;
        if (rec.vehicle->needsCharger()) energy = hours; // EV charging = hours parked

        rec.exitHour = rec.arrival + hours;
        rec.bill = rec.vehicle->billing(hours, energy);
        cout << "\n>> " << rec.vehicle->typeName() << " " << plate << " checked out. Bill: $" << rec.bill << "\n";

        // Free the slot
        if (rec.zone == "Truck") truckSlotsAvailable += rec.vehicle->requiredSlots();
        else if (rec.zone == "EV") evSlotsAvailable += rec.vehicle->requiredSlots();
        else normalSlotsAvailable += rec.vehicle->requiredSlots();

        // Park waiting vehicles if space is now available
        if (!waitingQueue.empty()) {
            Vehicle* next = waitingQueue.front();
            waitingQueue.erase(waitingQueue.begin());
            parkVehicle(next);
        }
    }

    void displayGarage() {
        cout << "\n=============== GARAGE STATUS =================\n";
        cout << "\n===== Available Slots ===== \n" << endl;
        cout<<"Normal: " <<"[ "<< normalSlotsAvailable <<" ] " << endl;
        cout << "EV: " <<"[ "<< evSlotsAvailable << " ] "<< endl;
        cout << "Truck: " << "[ "<< truckSlotsAvailable<< " ]" << endl;

        cout << "\nAll Vehicles (Parked & Exited):\n";
        cout << left << setw(12) << "Plate" << setw(15) << "Type" << setw(10) << "Zone"
            << setw(8) << "Arrival" << setw(8) << "Exit" << setw(8) << "Bill" << "\n";

        for (auto& p : allVehicles) {
            string exitDisplay = (p.exitHour == -1 ? "-" : to_string(p.exitHour));
            string billDisplay = (p.exitHour == -1 ? "-" : to_string(p.bill));
            cout << setw(12) << p.vehicle->getPlate()
                << setw(15) << p.vehicle->typeName()
                << setw(10) << p.zone
                << setw(8) << p.arrival
                << setw(8) << exitDisplay
                << setw(8) << billDisplay << "\n";
        }

        if (!waitingQueue.empty()) {
            cout << "\nWaiting Queue: ";
            for (auto& v : waitingQueue) cout << v->getPlate() << " ";
            cout << "\n";
        }

        cout << "=========================\n";
    }
};

// ---------- Main ----------
int main() {
    srand(time(0));

    int normalCount, evCount, truckCount;
    cout << "Enter number of Normal slots: "; cin >> normalCount;
    cout << "Enter number of EV slots: "; cin >> evCount;
    cout << "Enter number of Truck slots: "; cin >> truckCount;

    ParkingLot lot(normalCount, evCount, truckCount);

    while (true) {
        cout << "\n---- Automated Parking System ----\n";
        cout << "1. Park Vehicle\n2. Exit Vehicle\n3. Display Garage\n4. Exit Program\n";
        cout << "Choose an option: ";
        int choice; cin >> choice;

        if (choice == 1) {
            cout << "Select vehicle type:\n1. Car\n2. Motorbike\n3. Electric Car\n4. Truck\n5. Rickshaw\n";
            int type; cin >> type;
            string plate; int hour;
            cout << "Enter plate number: "; cin >> plate;
            cout << "Enter arrival hour: "; cin >> hour;
            Vehicle* v = nullptr;

            if (type == 1) v = new Car(plate, hour);
            else if (type == 2) {
                cout << "Select Motorbike type:\n1. NormalBike\n2. HeavyBike\n";
                int mtype; cin >> mtype;
                if (mtype == 1) v = new NormalBike(plate, hour);
                else v = new HeavyBike(plate, hour);
            }
            else if (type == 3) v = new ElectricCar(plate, hour);
            else if (type == 4) v = new Truck(plate, hour);
            else if (type == 5) v = new Rickshaw(plate, hour);
            else { cout << "Invalid type!\n"; continue; }

            lot.parkVehicle(v);
        }
        else if (choice == 2) {
            string plate; int hours;
            cout << "Enter plate number to exit: "; cin >> plate;
            cout << "Enter hours parked: "; cin >> hours;
            lot.exitVehicle(plate, hours);
        }
        else if (choice == 3) lot.displayGarage();
        else if (choice == 4) { cout << "Exiting system. Goodbye!\n"; break; }
        else cout << "Invalid choice!\n";
    }

    return 0;
}
