#include <iostream>
#include <vector>
#include <string>
#include <iomanip>
#include <regex> //Header file used to check for patterns especially like number plates
using namespace std;

class Vehicle { //Parent class
protected: //No outsiders can access unless friend or children since this is important information
    string plate;
    string arrivalHour;
public:
    Vehicle(string p, string h) : plate(p), arrivalHour(h) {}
    virtual ~Vehicle() {}
    string getPlate() { return plate; } //Plate number for identification
    string getArrival() { return arrivalHour; } //Arrival time

    virtual int requiredSlots() = 0; //Each vehicle must tell us how many slots it needs
    virtual bool needsCharger() { return false; } //Only for EV's
    virtual double billing(int hours, double energy = 0) = 0;
    virtual string typeName() = 0;
};
//Child classes
class Car : public Vehicle { 
public:
    Car(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 200 * hours; }
    string typeName() override { return "Car"; }
};

class ElectricCar : public Vehicle {
public:
    ElectricCar(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    bool needsCharger() override { return true; }
    double billing(int hours, double energy = 0) override { return 200 * hours + 0.3 * energy; } //Bill gets effected by the energy used for charging
    string typeName() override { return "ElectricCar"; }
    void startCharging() { cout << plate << " is now charging.\n"; }
};

class Truck : public Vehicle {
public:
    Truck(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 2; }
    double billing(int hours, double energy = 0) override { return 350 * hours; }
    string typeName() override { return "Truck"; }
};

class Rickshaw : public Vehicle {
public:
    Rickshaw(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 170 * hours; }
    string typeName() override { return "Rickshaw"; }
};

class Motorbike : public Vehicle {
public:
    Motorbike(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 100 * hours; }
    string typeName() override { return "Motorbike"; }
};

class NormalBike : public Motorbike {
public:
    NormalBike(string p, string h) : Motorbike(p, h) {}
    double billing(int hours, double energy = 0) override { return 100 * hours; }
    string typeName() override { return "NormalBike"; }
};

class HeavyBike : public Motorbike {
public:
    HeavyBike(string p, string h) : Motorbike(p, h) {}
    double billing(int hours, double energy = 0) override { return 150 * hours; }
    string typeName() override { return "HeavyBike"; }
};

struct ParkRecord {
    Vehicle* vehicle;
    string arrival;
    double energyUsed;
    string zone;
    double bill;
};

class ParkingLot {
    //Slots have 3 categories
    int normalSlotsAvailable; //For car,motorcyles,rickshaws
    int evSlotsAvailable; //For EV's ONLY
    int truckSlotsAvailable; //For trucks ONLY
    vector<Vehicle*> waitingQueue; //For the vehicLes waiting 
    vector<ParkRecord> allVehicles; //Record of all vehicles
public:
    ParkingLot(int normal, int ev, int truck)
        : normalSlotsAvailable(normal), evSlotsAvailable(ev), truckSlotsAvailable(truck) {
    }

    void parkVehicle(Vehicle* v) {
        string zone = "";
        bool parked = false;

        if (v->typeName() == "Truck") { // Depending on the vehicle it gets parked in relevant slot
            if (truckSlotsAvailable >= v->requiredSlots()) {
                truckSlotsAvailable -= v->requiredSlots(); //Total number of slots decrease by 1
                zone = "Truck";
                parked = true;
            }
        }
        else if (v->needsCharger()) {
            if (evSlotsAvailable >= v->requiredSlots()) {
                evSlotsAvailable -= v->requiredSlots();
                zone = "EV";
                parked = true;
            }
        }
        else {
            if (normalSlotsAvailable >= v->requiredSlots()) {
                normalSlotsAvailable -= v->requiredSlots();
                zone = "Normal";
                parked = true;
            }
        }

        if (parked) {
            allVehicles.push_back({ v, v->getArrival(), 0.0, zone, 0.0 }); //Save the parking information
            cout << "\n>> " << v->typeName() << " with plate " << v->getPlate()
                << " parked in " << zone << " zone at " << v->getArrival() << ".\n";

            ElectricCar* ec = dynamic_cast<ElectricCar*>(v);
            if (ec) ec->startCharging(); //This ensures that ONLY EV'S start auto charging when parked
        }
        else {
            waitingQueue.push_back(v); //And if the parking is full vehicle goes to waiting
            cout << "\n>> " << v->typeName() << " with plate " << v->getPlate()
                << " cannot be parked. Garage has reached its limit!\n";
        }
    }
    //For exiting a vehicle
    void exitVehicle(string plate, int hoursParked) { 
        int found = -1;
        for (int i = 0; i < allVehicles.size(); i++)
            if (allVehicles[i].vehicle->getPlate() == plate && allVehicles[i].bill == 0.0) { //Loop for checking if the car is in the parking currently
                found = i;
                break;
            }

        if (found == -1) {
            cout << "Vehicle not found or already exited.\n";
            return;
        }

        ParkRecord& rec = allVehicles[found];
        double energy = 0.0;
        if (rec.vehicle->needsCharger()) energy = hoursParked;
        //For billing
        rec.bill = rec.vehicle->billing(hoursParked, energy); 

        cout << "\n>> " << rec.vehicle->typeName() << " " << plate
            << " checked out. Bill: RS." << rec.bill << "\n";

        // Free the slot
        if (rec.zone == "Truck") truckSlotsAvailable += rec.vehicle->requiredSlots();
        else if (rec.zone == "EV") evSlotsAvailable += rec.vehicle->requiredSlots();
        else normalSlotsAvailable += rec.vehicle->requiredSlots();

        // Park waiting vehicles if space available if the waitingqueue is not empty
        if (!waitingQueue.empty()) {
            Vehicle* next = waitingQueue.front();
            waitingQueue.erase(waitingQueue.begin());
            parkVehicle(next);
        }
    }
    //Basic display function
    void displayGarage() {
        cout << "\n=============== GARAGE STATUS =================\n";
        cout << "\nAvailable Slots:\n";
        cout << "Normal: [" << normalSlotsAvailable << "]\n";
        cout << "EV: [" << evSlotsAvailable << "]\n";
        cout << "Truck: [" << truckSlotsAvailable << "]\n";

        cout << "\nAll Vehicles (Parked & Exited):\n";
        cout << left << setw(12) << "Plate" << setw(15) << "Type" << setw(10) << "Zone"
            << setw(12) << "Arrival" << setw(8) << "Bill" << "\n";

        for (auto& p : allVehicles) {
            string billDisplay = (p.bill == 0.0 ? "-" : to_string((int)p.bill));
            cout << setw(12) << p.vehicle->getPlate()
                << setw(15) << p.vehicle->typeName()
                << setw(10) << p.zone
                << setw(12) << p.arrival
                << setw(8) << billDisplay << "\n";
        }

        if (!waitingQueue.empty()) {
            cout << "\nWaiting Queue: ";
            for (auto& v : waitingQueue) cout << v->getPlate() << " ";
            cout << "\n";
        }

        cout << "=========================\n";
    }
};

// Validity functions 
bool validPlate(const string& plate) { //Checks if the user input plate number is valid or not
    regex plateFormat("[A-Z]{3}-[0-9]{3}"); //ABC-123 3 letters,a dash, 3 digits
    return regex_match(plate, plateFormat); // regex_match() is an inbuilt c++ function under the <regex> lib it is used to check if a string matches a regex pattern
}

bool validTime(const string& time) {  // 24-HOUR FORMAT
    regex timeFormat("([0-1]?[0-9]|2[0-3]):([0-5][0-9])");  //Ssame <regex> header function
    return regex_match(time, timeFormat);
}
int main() {

    int normalCount, evCount, truckCount;
    //You have to manually enter the total number of available slots for each Vehicle1
    cout << "Enter number of Normal slots: "; cin >> normalCount;
    cout << "Enter number of EV slots: "; cin >> evCount;
    cout << "Enter number of Truck slots: "; cin >> truckCount;

    ParkingLot lot(normalCount, evCount, truckCount);

    while (true) {
        cout << "\n---- Automated Parking System ----\n";
        cout << "1. Park Vehicle\n2. Exit Vehicle\n3. Display Garage\n4. Exit Program\n";
        cout << "Choose an option: ";
        int choice; cin >> choice;
        //Choosing the Vehicle
        if (choice == 1) {
            cout << "Select vehicle type:\n1. Car\n2. Motorbike\n3. Electric Car\n4. Truck\n5. Rickshaw\n";
            int type; cin >> type;
            if (type < 1 || type > 5) { cout << "Invalid vehicle type!\n"; continue; }

            string plate;
            do {
                cout << "Enter plate number (e.g., ABC-123): ";
                cin >> plate;
                if (!validPlate(plate)) cout << "Invalid plate format!\n";
            } while (!validPlate(plate));

            string arrival;
            cin.ignore();
            do {
                cout << "Enter arrival time (24-hour format HH:MM, e.g., 14:30 for 2:30 PM): ";
                getline(cin, arrival);
                if (!validTime(arrival)) cout << "Invalid time format! Use HH:MM (00:00 to 23:59)\n";
            } while (!validTime(arrival));

            Vehicle* v = nullptr;
            if (type == 1) v = new Car(plate, arrival);
            else if (type == 2) {
                cout << "Select Motorbike type:\n1. NormalBike\n2. HeavyBike\n";
                int mtype; cin >> mtype;
                if (mtype == 1) v = new NormalBike(plate, arrival);
                else v = new HeavyBike(plate, arrival);
            }
            else if (type == 3) v = new ElectricCar(plate, arrival);
            else if (type == 4) v = new Truck(plate, arrival);
            else if (type == 5) v = new Rickshaw(plate, arrival);

            lot.parkVehicle(v);
        }
        else if (choice == 2) {
            string plate; int hours;
            cout << "Enter plate number to exit: "; cin >> plate;
            cout << "Enter hours parked: "; cin >> hours;
            lot.exitVehicle(plate, hours);
        }
        else if (choice == 3) lot.displayGarage();
        else if (choice == 4) { cout << "Exiting system. Goodbye!\n"; break; }
        else cout << "Invalid choice!\n";
    }

    return 0;
}
