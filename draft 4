#include <iostream>
#include <vector>
#include <string>
#include <iomanip>
#include <regex>
#include <sstream>
using namespace std;

// ---------- Vehicle Base Class ----------
class Vehicle {
protected:
    string plate;
    string arrivalHour; // now string "HH:MM AM/PM"
public:
    Vehicle(string p, string h) : plate(p), arrivalHour(h) {}
    virtual ~Vehicle() {}
    string getPlate() { return plate; } //get plate number
    string getArrival() { return arrivalHour; } //arrival time

    virtual int requiredSlots() = 0; //slots required for each vehicle
    virtual bool needsCharger() { return false; } //charging function for EV's
    virtual double billing(int hours, double energy = 0) = 0; //bill for parking(varies with each vehicle), for EV energy contributes to bill
    virtual string typeName() = 0; //output name
};

// ---------- Vehicle Types ----------
class Car : public Vehicle {
public:
    Car(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 200 * hours; }
    string typeName() override { return "Car"; }
};

class ElectricCar : public Vehicle {
public:
    ElectricCar(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    bool needsCharger() override { return true; }
    double billing(int hours, double energy = 0) override { return 200 * hours + 0.3 * energy; } // energy = hours parked
    string typeName() override { return "ElectricCar"; }
    void startCharging() { cout << plate << " is now charging.\n"; }
};

class Truck : public Vehicle {
public:
    Truck(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 2; }
    double billing(int hours, double energy = 0) override { return 350 * hours; }
    string typeName() override { return "Truck"; }
};

class Rickshaw : public Vehicle {
public:
    Rickshaw(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 170 * hours; }
    string typeName() override { return "Rickshaw"; }
};

class Motorbike : public Vehicle {
public:
    Motorbike(string p, string h) : Vehicle(p, h) {}
    int requiredSlots() override { return 1; }
    double billing(int hours, double energy = 0) override { return 100 * hours; }
    string typeName() override { return "Motorbike"; }
};

class NormalBike : public Motorbike {
public:
    NormalBike(string p, string h) : Motorbike(p, h) {}
    double billing(int hours, double energy = 0) override { return 100 * hours; }
    string typeName() override { return "NormalBike"; }
};

class HeavyBike : public Motorbike {
public:
    HeavyBike(string p, string h) : Motorbike(p, h) {}
    double billing(int hours, double energy = 0) override { return 150 * hours; }
    string typeName() override { return "HeavyBike"; }
};

// ---------- Parking Record ----------
struct ParkRecord {
    Vehicle* vehicle;
    string arrival;
    double energyUsed;
    string zone;
    double bill;
};

// ---------- Parking Lot ----------
class ParkingLot {
    int normalSlotsAvailable;
    int evSlotsAvailable;
    int truckSlotsAvailable;
    vector<Vehicle*> waitingQueue;
    vector<ParkRecord> allVehicles; // includes parked and exited vehicles
public:
    ParkingLot(int normal, int ev, int truck)
        : normalSlotsAvailable(normal), evSlotsAvailable(ev), truckSlotsAvailable(truck) {}

    void parkVehicle(Vehicle* v) {
        string zone = "";
        bool parked = false;

        if (v->typeName() == "Truck") {
            if (truckSlotsAvailable >= v->requiredSlots()) {
                truckSlotsAvailable -= v->requiredSlots();
                zone = "Truck";
                parked = true;
            }
        }
        else if (v->needsCharger()) {
            if (evSlotsAvailable >= v->requiredSlots()) {
                evSlotsAvailable -= v->requiredSlots();
                zone = "EV";
                parked = true;
            }
        }
        else {
            if (normalSlotsAvailable >= v->requiredSlots()) {
                normalSlotsAvailable -= v->requiredSlots();
                zone = "Normal";
                parked = true;
            }
        }

        if (parked) {
            allVehicles.push_back({ v, v->getArrival(), 0.0, zone, 0.0 });
            cout << "\n>> " << v->typeName() << " with plate " << v->getPlate() << " parked in " << zone << " zone.\n";

            ElectricCar* ec = dynamic_cast<ElectricCar*>(v);
            if (ec) ec->startCharging();
        }
        else {
            waitingQueue.push_back(v);
            cout << "\n>> " << v->typeName() << " with plate " << v->getPlate() << " cannot be parked. Garage has reached its limit!\n";
        }
    }

    // ---------- Exit Vehicle ----------
    void exitVehicle(string plate, int hoursParked) {
        int found = -1;
        for (int i = 0; i < allVehicles.size(); i++)
            if (allVehicles[i].vehicle->getPlate() == plate && allVehicles[i].bill == 0.0) {
                found = i;
                break;
            }

        if (found == -1) {
            cout << "Vehicle not found or already exited.\n";
            return;
        }

        ParkRecord& rec = allVehicles[found];
        double energy = 0.0;
        if (rec.vehicle->needsCharger()) energy = hoursParked;

        rec.bill = rec.vehicle->billing(hoursParked, energy);

        cout << "\n>> " << rec.vehicle->typeName() << " " << plate << " checked out. Bill: RS." << rec.bill << "\n";

        // Free the slot
        if (rec.zone == "Truck") truckSlotsAvailable += rec.vehicle->requiredSlots();
        else if (rec.zone == "EV") evSlotsAvailable += rec.vehicle->requiredSlots();
        else normalSlotsAvailable += rec.vehicle->requiredSlots();

        // Park waiting vehicles if space available
        if (!waitingQueue.empty()) {
            Vehicle* next = waitingQueue.front();
            waitingQueue.erase(waitingQueue.begin());
            parkVehicle(next);
        }
    }

    // ---------- Display Garage ----------
    void displayGarage() {
        cout << "\n=============== GARAGE STATUS =================\n";
        cout << "\nAvailable Slots:\n";
        cout << "Normal: [" << normalSlotsAvailable << "]\n";
        cout << "EV: [" << evSlotsAvailable << "]\n";
        cout << "Truck: [" << truckSlotsAvailable << "]\n";

        cout << "\nAll Vehicles (Parked & Exited):\n";
        cout << left << setw(12) << "Plate" << setw(15) << "Type" << setw(10) << "Zone"
             << setw(12) << "Arrival" << setw(8) << "Bill" << "\n";

        for (auto& p : allVehicles) {
            string billDisplay = (p.bill == 0.0 ? "-" : to_string((int)p.bill));
            cout << setw(12) << p.vehicle->getPlate()
                 << setw(15) << p.vehicle->typeName()
                 << setw(10) << p.zone
                 << setw(12) << p.arrival
                 << setw(8) << billDisplay << "\n";
        }

        if (!waitingQueue.empty()) {
            cout << "\nWaiting Queue: ";
            for (auto& v : waitingQueue) cout << v->getPlate() << " ";
            cout << "\n";
        }

        cout << "=========================\n";
    }
};

// ---------- Utility Functions ----------
bool validPlate(const string& plate) {
    regex plateFormat("[A-Z]{3}-[0-9]{3}"); // ABC-123
    return regex_match(plate, plateFormat);
}

bool validTime(const string& time) {
    regex timeFormat("([0-1]?[0-9]):([0-5][0-9]) (AM|PM)");
    return regex_match(time, timeFormat);
}

// ---------- Main ----------
int main() {
    int normalCount, evCount, truckCount;
    cout << "Enter number of Normal slots: "; cin >> normalCount;
    cout << "Enter number of EV slots: "; cin >> evCount;
    cout << "Enter number of Truck slots: "; cin >> truckCount;

    ParkingLot lot(normalCount, evCount, truckCount);

    while (true) {
        cout << "\n---- Automated Parking System ----\n";
        cout << "1. Park Vehicle\n2. Exit Vehicle\n3. Display Garage\n4. Exit Program\n";
        cout << "Choose an option: ";
        int choice; cin >> choice;

        if (choice == 1) {
            cout << "Select vehicle type:\n1. Car\n2. Motorbike\n3. Electric Car\n4. Truck\n5. Rickshaw\n";
            int type; cin >> type;
            if (type < 1 || type > 5) { cout << "Invalid vehicle type!\n"; continue; }

            string plate;
            do {
                cout << "Enter plate number (e.g., ABC-123): ";
                cin >> plate;
                if (!validPlate(plate)) cout << "Invalid plate format!\n";
            } while (!validPlate(plate));

            string arrival;
            cin.ignore(); // flush newline
            do {
                cout << "Enter arrival time (HH:MM AM/PM): ";
                getline(cin, arrival);
                if (!validTime(arrival)) cout << "Invalid time format!\n";
            } while (!validTime(arrival));

            Vehicle* v = nullptr;
            if (type == 1) v = new Car(plate, arrival);
            else if (type == 2) {
                cout << "Select Motorbike type:\n1. NormalBike\n2. HeavyBike\n";
                int mtype; cin >> mtype;
                if (mtype == 1) v = new NormalBike(plate, arrival);
                else v = new HeavyBike(plate, arrival);
            }
            else if (type == 3) v = new ElectricCar(plate, arrival);
            else if (type == 4) v = new Truck(plate, arrival);
            else if (type == 5) v = new Rickshaw(plate, arrival);

            lot.parkVehicle(v);
        }
        else if (choice == 2) {
            string plate; int hours;
            cout << "Enter plate number to exit: "; cin >> plate;
            cout << "Enter hours parked: "; cin >> hours;
            lot.exitVehicle(plate, hours);
        }
        else if (choice == 3) lot.displayGarage();
        else if (choice == 4) { cout << "Exiting system. Goodbye!\n"; break; }
        else cout << "Invalid choice!\n";
    }

    return 0;
}
